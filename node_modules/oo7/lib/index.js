'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.setDefaultTransformBondContext = setDefaultTransformBondContext;

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var defaultContext = typeof parity === 'undefined' ? null : parity.api;

function setDefaultTransformBondContext(c) {
	defaultContext = c;
}

var subscripted = {};
// Any names which should never be subscripted.
var reservedNames = { toJSON: true, toString: true };

function symbolValues(o) {
	return Object.getOwnPropertySymbols(o).map(function (k) {
		return o[k];
	});
}

var Bond = exports.Bond = function () {
	function Bond() {
		var mayBeNull = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

		_classCallCheck(this, Bond);

		this.subscribers = {};
		this.notifies = {};
		this.thens = [];
		this._ready = false;
		this._value = null;
		this.mayBeNull = mayBeNull;
		this._users = 0;
		this._triggering = false;
		//		return this.subscriptable();
	}

	_createClass(Bond, [{
		key: 'toString',
		value: function toString() {
			//		console.log(`Converting Bond to string: ${JSON.stringify(this)}`)
			var s = Symbol();
			subscripted[s] = this;
			return s;
		}
	}, {
		key: 'mapToString',
		value: function mapToString() {
			return this.map(function (_) {
				return _.toString();
			});
		}
	}, {
		key: 'subscriptable',
		value: function subscriptable() {
			var depth = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;

			if (depth === 0) return this;
			var r = new Proxy(this, {
				get: function get(receiver, name) {
					//				console.log(`subscriptable.get: ${JSON.stringify(receiver)}, ${JSON.stringify(name)}, ${JSON.stringify(receiver)}: ${typeof(name)}, ${typeof(receiver[name])}`);
					if ((typeof name === 'string' || typeof name === 'number') && (reservedNames[name] || typeof receiver[name] !== 'undefined')) {
						return receiver[name];
					} else if ((typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'symbol') {
						if (Bond.knowSymbol(name)) {
							return receiver.sub(Bond.fromSymbol(name)).subscriptable(depth - 1);
						} else {
							//						console.warn(`Unknown symbol given`);
							return null;
						}
					} else {
						//					console.log(`Subscripting: ${JSON.stringify(name)}`)
						return receiver.sub(name).subscriptable(depth - 1);
					}
				}
			});
			//		r.toString = Bond.prototype.toString.bind(this);
			return r;
		}
	}, {
		key: 'reset',
		value: function reset() {
			if (this._ready) {
				this._ready = false;
				this._value = null;
				symbolValues(this.notifies).forEach(function (f) {
					return f();
				});
			}
		}
	}, {
		key: 'changed',
		value: function changed(v) {
			if (typeof v === 'undefined') {
				return;
			}
			//		console.log(`maybe changed (${this._value} -> ${v})`);
			if (!this.mayBeNull && v === null) {
				this.reset();
			} else if (!this._ready || JSON.stringify(v) !== JSON.stringify(this._value)) {
				this.trigger(v);
			}
		}
	}, {
		key: 'trigger',
		value: function trigger(v) {
			var _this = this;

			if (typeof v === 'undefined') {
				console.error('Trigger called with undefined value');
				return;
			}
			if (this._triggering) {
				console.error('Trigger cannot be called while already triggering.');
				return;
			}
			this._triggering = true;
			if (!this.mayBeNull && v === null) {
				this.reset();
			} else {
				//			console.log(`firing (${JSON.stringify(v)})`);
				this._ready = true;
				this._value = v;
				symbolValues(this.notifies).forEach(function (f) {
					return f();
				});
				symbolValues(this.subscribers).forEach(function (f) {
					return f(_this._value);
				});
				this.thens.forEach(function (f) {
					f(_this._value);
					_this.drop();
				});
				this.thens = [];
			}
			this._triggering = false;
		}
		// If you use this, you are responsible for calling drop exactly once
		// at some point later. Some Bonds won't work properly unless you call
		// this.

	}, {
		key: 'use',
		value: function use() {
			if (this._users == 0) {
				this.initialise();
			}
			this._users++;
			return this;
		}
		// To be called exactly once for each time you call pick. The object won't
		// work properly after calling this.

	}, {
		key: 'drop',
		value: function drop() {
			if (this._users == 0) {
				throw 'mismatched use()/drop(): drop() called once more than expected!';
			}
			this._users--;
			if (this._users == 0) {
				this.finalise();
			}
		}

		// Will be called at most once. Object must work properly after this.

	}, {
		key: 'initialise',
		value: function initialise() {}
		// Will be called at most once. Object must clean up after this.

	}, {
		key: 'finalise',
		value: function finalise() {}

		// must call unnotify exactly once when finished with it.

	}, {
		key: 'notify',
		value: function notify(f) {
			this.use();
			var id = Symbol();
			this.notifies[id] = f;
			if (this._ready) {
				f();
			}
			return id;
		}
	}, {
		key: 'unnotify',
		value: function unnotify(id) {
			delete this.notifies[id];
			this.drop();
		}

		// must call untie exactly once when finished with it.

	}, {
		key: 'tie',
		value: function tie(f) {
			this.use();
			var id = Symbol();
			this.subscribers[id] = f;
			if (this._ready) {
				f(this._value);
			}
			return id;
		}
	}, {
		key: 'untie',
		value: function untie(id) {
			delete this.subscribers[id];
			this.drop();
		}
	}, {
		key: 'subscribe',
		value: function subscribe(f) {
			console.warn('Bond.subscribe is deprecated. Use Bond.tie instead.');
			return this.tie(f);
		}
	}, {
		key: 'ready',
		value: function ready() {
			return this._ready;
		}
	}, {
		key: 'then',
		value: function then(f) {
			this.use();
			if (this._ready) {
				f(this._value);
				this.drop();
			} else {
				this.thens.push(f);
			}
			return this;
		}
	}, {
		key: 'done',
		value: function done(f) {
			var _this2 = this;

			if (this.isDone === undefined) {
				throw 'Cannot call done() on Bond that has no implementation of isDone.';
			}
			var id;
			var h = function h(s) {
				if (_this2.isDone(s)) {
					f(s);
					_this2.untie(id);
				}
			};
			id = this.tie(h);
			return this;
		}
	}, {
		key: 'map',
		value: function map(f) {
			var outResolveDepth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
			var resolveDepth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;

			return new TransformBond(f, [this], [], outResolveDepth, resolveDepth);
		}
	}, {
		key: 'sub',
		value: function sub(name) {
			var outResolveDepth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
			var resolveDepth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;

			return new TransformBond(function (r, n) {
				return r[n];
			}, [this, name], [], outResolveDepth, resolveDepth);
		}

		// Takes a Bond which evaluates to a = [a[0], a[1], ...]
		// Returns Bond which evaluates to:
		// null iff a.length === 0
		// f(i, a[0])[0] iff f(i, a[0])[1] === true
		// fold(f(0, a[0]), a.mid(1)) otherwise

	}, {
		key: 'reduce',
		value: function reduce(accum, init) {
			var nextItem = function nextItem(acc, rest) {
				var next = rest.pop();
				return Bond.promise([accum(acc, next)]).then(function (_ref) {
					var _ref2 = _slicedToArray(_ref, 1),
					    _ref2$ = _slicedToArray(_ref2[0], 2),
					    v = _ref2$[0],
					    i = _ref2$[1];

					return i ? v : rest.length > 0 ? nextItem(v, rest) : null;
				});
			};
			return this.map(function (a) {
				return nextItem(init, a);
			});
		}
	}], [{
		key: 'knowSymbol',
		value: function knowSymbol(name) {
			return !!subscripted[name];
		}
	}, {
		key: 'fromSymbol',
		value: function fromSymbol(name) {
			var sub = subscripted[name];
			delete subscripted[name];
			return sub;
		}
	}, {
		key: 'all',
		value: function all(list) {
			return new TransformBond(function () {
				for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
					args[_key] = arguments[_key];
				}

				return args;
			}, list);
		}
	}, {
		key: 'mapAll',
		value: function mapAll(list, f) {
			var outResolveDepth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
			var resolveDepth = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;

			return new TransformBond(function () {
				return f.apply(undefined, arguments);
			}, list, [], outResolveDepth, resolveDepth);
		}
	}, {
		key: 'promise',
		value: function promise(list) {
			return new Promise(function (resolve, reject) {
				var finished = 0;
				var l = [];
				l.length = list.length;

				var done = function done(i, v) {
					//				console.log(`done ${i} ${v}`);
					l[i] = v;
					finished++;
					//				console.log(`finished ${finished}; l.length ${l.length}`);
					if (finished === l.length) {
						//					console.log(`resolving with ${l}`);
						resolve(l);
					}
				};

				list.forEach(function (v, i) {
					if (v instanceof Bond) {
						v.then(function (x) {
							return done(i, x);
						});
					} else if (v instanceof Promise) {
						v.then(function (x) {
							return done(i, x);
						}, reject);
					} else {
						done(i, v);
					}
				});
			});
		}
	}]);

	return Bond;
}();

function isReady(x, depthLeft) {
	if ((typeof x === 'undefined' ? 'undefined' : _typeof(x)) === 'object' && x !== null) {
		if (x instanceof Bond) return x._ready;else if (x instanceof Promise) return typeof x._value !== 'undefined';else if (depthLeft > 0 && x.constructor === Array) return x.every(function (i) {
			return isReady(i, depthLeft - 1);
		});else if (depthLeft > 0 && x.constructor === Object) return Object.keys(x).every(function (k) {
			return isReady(x[k], depthLeft - 1);
		});else return true;
	} else return true;
}

function isPlain(x, depthLeft) {
	if ((typeof x === 'undefined' ? 'undefined' : _typeof(x)) === 'object' && x !== null) {
		if (x instanceof Bond) return false;else if (x instanceof Promise) return false;else if (depthLeft > 0 && x.constructor === Array) return x.every(function (i) {
			return isPlain(i, depthLeft - 1);
		});else if (depthLeft > 0 && x.constructor === Object) return Object.keys(x).every(function (k) {
			return isPlain(x[k], depthLeft - 1);
		});else return true;
	} else return true;
}

function isArrayWithNonPlainItems(x, depthLeft) {
	return depthLeft > 0 && x.constructor === Array && (depthLeft == 1 && x.findIndex(function (i) {
		return i instanceof Bond || i instanceof Promise;
	}) != -1 || depthLeft > 1 && x.findIndex(function (i) {
		return i instanceof Bond || i instanceof Promise || i instanceof Array || i instanceof Object;
	}) != -1);
}

function isObjectWithNonPlainItems(x, depthLeft) {
	return depthLeft > 0 && x.constructor === Object && (depthLeft == 1 && Object.keys(x).findIndex(function (i) {
		return x[i] instanceof Bond || x[i] instanceof Promise;
	}) != -1 || depthLeft > 1 && Object.keys(x).findIndex(function (i) {
		return x[i] instanceof Bond || x[i] instanceof Promise || x[i] instanceof Array || x[i] instanceof Object;
	}) != -1);
}

function mapped(x, depthLeft) {
	if (!isReady(x, depthLeft)) {
		throw 'Internal error: Unready value being mapped';
	}
	//	console.log(`x info: ${x} ${typeof(x)} ${x.constructor.name} ${JSON.stringify(x)}; depthLeft: ${depthLeft}`);
	if ((typeof x === 'undefined' ? 'undefined' : _typeof(x)) === 'object' && x !== null) {
		if (x instanceof Bond) {
			if (x._ready !== true) {
				throw 'Internal error: Unready Bond being mapped';
			}
			if (typeof x._value === 'undefined') {
				throw 'Internal error: Ready Bond with undefined value in mapped';
			}
			//			console.log(`Bond: ${JSON.stringify(x._value)}}`);
			return x._value;
		} else if (x instanceof Promise) {
			if (typeof x._value === 'undefined') {
				throw 'Internal error: Ready Promise has undefined value';
			}
			//			console.log(`Promise: ${JSON.stringify(x._value)}}`);
			return x._value;
		} else if (isArrayWithNonPlainItems(x, depthLeft)) {
			//			console.log(`Deep array...`);
			var _o = x.slice().map(function (i) {
				return mapped(i, depthLeft - 1);
			});
			//			console.log(`...Deep array: ${JSON.stringify(o)}`);
			return _o;
		} else if (isObjectWithNonPlainItems(x, depthLeft)) {
			var o = {};
			//			console.log(`Deep object...`);
			Object.keys(x).forEach(function (k) {
				o[k] = mapped(x[k], depthLeft - 1);
			});
			//			console.log(`...Deep object: ${JSON.stringify(o)}`);
			return o;
		} else {
			//			console.log(`Shallow object.`);
			return x;
		}
	} else {
		//		console.log(`Basic value.`);
		return x;
	}
}

function deepNotify(x, poll, ids, depthLeft) {
	//	console.log(`Setitng up deep notification on object: ${JSON.stringify(x)} - ${typeof(x)}/${x === null}/${x.constructor.name} (depthLeft: ${depthLeft})`);
	if ((typeof x === 'undefined' ? 'undefined' : _typeof(x)) === 'object' && x !== null) {
		if (x instanceof Bond) {
			ids.push(x.notify(poll));
			return true;
		} else if (x instanceof Promise) {
			x.then(function (v) {
				x._value = v;poll();
			});
			return true;
		} else if (isArrayWithNonPlainItems(x, depthLeft)) {
			var r = false;
			x.forEach(function (i) {
				r = deepNotify(i, poll, ids, depthLeft - 1) || r;
			});
			return r;
		} else if (isObjectWithNonPlainItems(x, depthLeft)) {
			var r = false;
			Object.keys(x).forEach(function (k) {
				r = deepNotify(x[k], poll, ids, depthLeft - 1) || r;
			});
			return r;
		} else {
			return false;
		}
	} else {
		return false;
	}
}

function deepUnnotify(x, ids, depthLeft) {
	if ((typeof x === 'undefined' ? 'undefined' : _typeof(x)) === 'object' && x !== null) {
		if (x instanceof Bond) {
			x.unnotify(ids.shift());
			return true;
		} else if (isArrayWithNonPlainItems(x, depthLeft)) {
			var r = false;
			x.forEach(function (i) {
				r = deepUnnotify(i, ids, depthLeft - 1) || r;
			});
			return r;
		} else if (isObjectWithNonPlainItems(x, depthLeft)) {
			var r = false;
			Object.keys(x).forEach(function (k) {
				r = deepUnnotify(x[k], ids, depthLeft - 1) || r;
			});
			return r;
		} else {
			return false;
		}
	} else {
		return false;
	}
}

var ReactiveBond = exports.ReactiveBond = function (_Bond) {
	_inherits(ReactiveBond, _Bond);

	function ReactiveBond(a, d) {
		var execute = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function (args) {
			return _this3.changed(args);
		};
		var mayBeNull = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
		var resolveDepth = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;

		_classCallCheck(this, ReactiveBond);

		var _this3 = _possibleConstructorReturn(this, (ReactiveBond.__proto__ || Object.getPrototypeOf(ReactiveBond)).call(this, mayBeNull));

		_this3._poll = function () {
			//			console.log(`Polling ReactiveBond with resolveDepth ${resolveDepth}`);
			if (a.every(function (i) {
				return isReady(i, resolveDepth);
			})) {
				//				console.log(`poll: All dependencies good...`);
				var am = a.map(function (i) {
					return mapped(i, resolveDepth);
				});
				//				console.log(`poll: Mapped dependencies: ${JSON.stringify(am)}`);
				execute.bind(_this3)(am);
			} else {
				//				console.log("poll: One or more dependencies undefined");
				_this3.reset();
			}
		};
		_this3._active = false;
		_this3._d = d.slice();
		_this3._a = a.slice();
		_this3.resolveDepth = resolveDepth;
		return _this3;
	}

	// TODO: implement isDone.


	_createClass(ReactiveBond, [{
		key: 'initialise',
		value: function initialise() {
			var _this4 = this;

			//		console.log(`Initialising ReactiveBond for resolveDepth ${this.resolveDepth}`);
			this._ids = [];
			this._d.forEach(function (_) {
				return _this4._ids.push(_.notify(_this4._poll));
			});
			var nd = 0;
			this._a.forEach(function (i) {
				if (deepNotify(i, _this4._poll, _this4._ids, _this4.resolveDepth)) nd++;
			});
			if (nd == 0 && this._d.length == 0) {
				this._poll();
			}
		}
	}, {
		key: 'finalise',
		value: function finalise() {
			var _this5 = this;

			//		console.log(`Finalising ReactiveBond with resolveDepth ${this.resolveDepth}`);
			this._d.forEach(function (_) {
				return _.unnotify(_this5._ids.shift());
			});
			this._a.forEach(function (_) {
				return deepUnnotify(_, _this5._ids, _this5.resolveDepth);
			});
		}
	}]);

	return ReactiveBond;
}(Bond);

// Just a one-off.


var ReactivePromise = exports.ReactivePromise = function (_ReactiveBond) {
	_inherits(ReactivePromise, _ReactiveBond);

	function ReactivePromise(a, d) {
		var execute = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function (args) {
			return _this6.changed(args);
		};
		var mayBeNull = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

		var _this6;

		var resolveDepth = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;

		_classCallCheck(this, ReactivePromise);

		var done = false;
		return _this6 = _possibleConstructorReturn(this, (ReactivePromise.__proto__ || Object.getPrototypeOf(ReactivePromise)).call(this, a, d, function (args) {
			if (!done) {
				done = true;
				execute.bind(_this6)(args);
			}
		}, mayBeNull, resolveDepth));
	}

	return ReactivePromise;
}(ReactiveBond);

/// f is function which returns a promise. a is a set of dependencies
/// which must be passed to f as args. d are dependencies whose values are
/// unneeded. any entries of a which are reactive promises then is it their
/// underlying value which is passed.
///
/// we return a bond (an ongoing promise).


var TransformBond = exports.TransformBond = function (_ReactiveBond2) {
	_inherits(TransformBond, _ReactiveBond2);

	function TransformBond(f) {
		var a = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
		var d = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
		var outResolveDepth = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
		var resolveDepth = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;
		var latched = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;
		var mayBeNull = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : true;
		var context = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : defaultContext;

		_classCallCheck(this, TransformBond);

		var _this7 = _possibleConstructorReturn(this, (TransformBond.__proto__ || Object.getPrototypeOf(TransformBond)).call(this, a, d, function (args) {
			var _this8 = this;

			//			console.log(`Applying: ${JSON.stringify(args)}`);
			this.dropOut();
			var r = f.apply(context, args);
			if (typeof r === 'undefined') {
				console.warn('Transformation returned undefined: Applied ' + f + ' to ' + JSON.stringify(args) + '.');
				this.reset();
			} else if (r instanceof Promise) {
				if (!latched) {
					this.reset();
				}
				r.then(this.changed.bind(this));
			} else if (!isPlain(r, outResolveDepth)) {
				//				console.log(`Using ReactiveBond to resolve and trigger non-plain result (at depth ${outResolveDepth})`);
				this.useOut(new ReactiveBond([r], [], function (_ref3) {
					var _ref4 = _slicedToArray(_ref3, 1),
					    v = _ref4[0];

					//					console.log(`Resolved results: ${JSON.stringify(v)}. Triggering...`);
					_this8.changed.bind(_this8)(v);
				}, false, outResolveDepth));
			} else {
				this.changed(r);
			}
		}, mayBeNull, resolveDepth));

		_this7._outBond = null;
		return _this7;
	}

	_createClass(TransformBond, [{
		key: 'useOut',
		value: function useOut(b) {
			this._outBond = b.use();
		}
	}, {
		key: 'dropOut',
		value: function dropOut() {
			if (this._outBond !== null) {
				this._outBond.drop();
			}
			this._outBond = null;
		}
	}, {
		key: 'finalise',
		value: function finalise() {
			this.dropOut();
			ReactiveBond.prototype.finalise.call(this);
		}
	}]);

	return TransformBond;
}(ReactiveBond);

var testIntervals = exports.testIntervals = {};

var TimeBond = exports.TimeBond = function (_Bond2) {
	_inherits(TimeBond, _Bond2);

	function TimeBond() {
		_classCallCheck(this, TimeBond);

		var _this9 = _possibleConstructorReturn(this, (TimeBond.__proto__ || Object.getPrototypeOf(TimeBond)).call(this));

		_this9.poll();
		return _this9;
	}

	_createClass(TimeBond, [{
		key: 'poll',
		value: function poll() {
			this.trigger(Date.now());
		}
	}, {
		key: 'initialise',
		value: function initialise() {
			if (typeof window !== 'undefined') this.interval = window.setInterval(this.poll.bind(this), 1000);else {
				this.interval = Object.keys(testIntervals).length + 1;
				testIntervals[this.interval] = this.poll.bind(this);
			}
		}
	}, {
		key: 'finalise',
		value: function finalise() {
			if (typeof window !== 'undefined') window.clearInterval(this.interval);else {
				if (!testIntervals[this.interval]) throw 'finalise() called multiple time on same timer!';
				delete testIntervals[this.interval];
			}
		}
	}]);

	return TimeBond;
}(Bond);